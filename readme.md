# node

the basics of node js: runtime enviroment, es6 modules setup, settinng a server , events in node, listening to requests, event loop, eniveroment variables

# mvc

the model-viewer-controller project setup, separates the data model, the code used to setup the application request and responses and the viewing templates . its almost impossible to separate the model and the controller. because they have to interact with each other to deal withe the requesta nd responses. A fat model and thin application is encouraged to reduce the amount of aplication validation needed.

# express

Introduces express basic concepts: the request response cycle, use morgan express-json params, abstraction of http methods response headers, chaining http methods, chainging custom middleware, creating , mounting and using sub routes.

middleware does not receive inputs

/ console.log(req.headers);// express turn all headers to lowercase.

# eslint - prettier setup

1. paste the .eslint.json config file <br>
2. install these packages `npm i eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-config-airbnb eslint-plugin-node eslint-plugin-jsx eslint-plugin-jsx-a11y eslint-plugin-react --save-dev`
3. `package.json` add `"engines": { "node": ">=20.0.0"}` or the preferred node version to stop linting errors

# definition schematics

user not users as an endpoint because only one person will be accessing the store at a time. Each store resource will also be accesed one at a time.

# error-handling

catch operational errors in async calls by proptoptyping the error class and adding that property, any other errors also have to be handled, moongodb and moonsgose validation errors are handled as operational using if statements. All the oher errors are passed to a error handler which is a callback function with four parameters, the 4 parameters tell moongose that any values passed to teh next middleware function are errors and this function will recieve them as error. they are two resposnes, the production and developement enviroment error responses. Other non-operational errors such as a promise rejection when trying to connect because errornet are handled in the server script, all errors in the middleware are handled by the global error handler and not 'caught as execption'.

# debugger

code changes in the debuger are saved
breakpoints.
run the node processes runs

then , catch((err)=> next(err)) , catch(next)

# authentication, authorization and security

1. signup- the signup handler will only create a new doc using select fields. min and max lengths on these fields to sanitize input. The security sensitive fields in the user model senstive fields are set to `select: false`. The passowrdChangedAt is not included The password and passwordConfirm fields are compared in the schema and if they match the passwordConfirm is set to `undefined`. The password is encrypted using the `bcryptjs` and stored encrypted. Other fields are validated by the schema. The user is then authenticated by sending a JsonWebToken.

2. JsonWebToken(JWT) is a authenticating algorithm that stores a token stateless in the browser cookies or local storage. The storage does not happen in the database to maintain the rest architecture. The jwt is generated by compiling headers, an user id, the token creation timestamp , expiring time and a secret key kept on the runtime enviroment variables. The secret key keeps the token secure. The token creation time stamp can be used to ensure that older tokens are invalidated. This timestamp also ensures that any tokens generated after a password change are invalidated

3. **Login**- get the email and password fields from the request, get the user using the email and use `select('+password');` to select the encrypted password field. use `compare()` from `bcrypt` to verify password and send jwt token if its correct.

4. **Protecting Routes**- restrict routes to only logged in users, invalidated jwt after password change and verify user roles for senstive routes. Logged in users are verified using the user id in teh `JWT` token. The token is invalidated if its creation timestap is later than the password change timestamp that is if password was changed atleast once. User roles have to be set manually on the db or through a secure route. The default user role is set set to `"user"` by default. A function that wraps the middleware can be used to restrict sensitive routes to user roles, the function receives the roles array, destructures, checks if the current user's role is included. The wrapped middleware will and returns `next()` if role is included in the user doc or `next(error)` if it is not included.

5. **Password Change**- On the forget password route random strings as a password reset token are created, the hashed result of the token and the reset token expiry timestamp saved to the database. Th reset token sent via email with an url that points to the reset passord route with the token as a param. On reset password route, the reset token is retrived, hashed and compared with the saved hash. The user with the hashed token saved is retreived if the reset token expiry still time is less than the current time stamp. The password and passwordConfirm saved, reset tokena and expiry time set to undefined. To update the password while logged in, the currentPassword is entered, hashed and verified agaionst the encyrpted and saved password.

6. **User Details Update**- on the protected `/updateme` routerequest fields are filtered, if the password fields are present error response is sent. Password cannot be updated using this route.
   The request body is filtered and only email and name values are saved.

# bruno

ofline api testing,

https://dev.to/vikas1712/introduction-to-bruno-scripting-5a1n

# best security practices

read slidees

//401 is means not authorized
